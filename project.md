# Техническая документация проекта Telegram Mini App

## Общая архитектура

Приложение представляет собой Telegram Mini App с монолитной архитектурой, состоящей из двух основных частей:
- **Backend** (Node.js/Express) - серверная часть с ботом, API и бизнес-логикой
- **Frontend** (React) - клиентское веб-приложение, интегрированное в Telegram

### Архитектурная схема

```
┌─────────────────────────────────────────────────────────────┐
│                    Telegram Platform                        │
│  ┌──────────────┐         ┌──────────────────────────┐      │
│  │ Telegram Bot │◄───────►│  Mini App (React SPA)     │     │
│  │  (Telegraf)  │         │  (Frontend)               │     │
│  └──────┬───────┘         └───────────┬────────────────┘    │
└─────────┼─────────────────────────────┼─────────────────────┘
          │                             │
          │                             │
┌─────────▼─────────────────────────────▼──────────────────────┐
│                    Backend Server                            │
│  ┌──────────────────────────────────────────────────────┐  │
│  │  Express API Server                                   │  │
│  │  - REST API endpoints                                │  │
│  │  - Static file serving (React build)                  │  │
│  │  - Swagger documentation                              │  │
│  └──────────────────────────────────────────────────────┘  │
│                                                              │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐     │
│  │   Payment    │  │  Referral    │  │ Notification │     │
│  │   Service    │  │   System     │  │   System     │     │
│  │ (YooKassa)   │  │              │  │              │     │
│  └──────────────┘  └──────────────┘  └──────────────┘     │
│                                                              │
│  ┌──────────────────────────────────────────────────────┐  │
│  │  Event Bus (EventEmitter)                             │  │
│  │  - Межмодульная коммуникация                          │  │
│  │  - События: payment.succeeded, referral.*, etc.      │  │
│  └──────────────────────────────────────────────────────┘  │
└─────────┬──────────────────────────┬───────────────────────┘
          │                          │
          │                          │
┌─────────▼──────────┐    ┌──────────▼──────────┐
│   PostgreSQL       │    │   Redis + BullMQ    │
│   - Users          │    │   - Queue           │
│   - Referrals      │    │   - Rate Limiting  │
│   - Notifications  │    │                     │
└────────────────────┘    └─────────────────────┘
```

## Технологический стэк

### Backend

**Основные технологии:**
- **Node.js** (ES Modules) - серверная платформа
- **Express.js** - веб-фреймворк для REST API
- **Telegraf** - библиотека для работы с Telegram Bot API
- **PostgreSQL** - основная база данных
- **Redis** - кэширование и очереди
- **BullMQ** - система очередей для фоновых задач
- **Bottleneck** - rate limiting для Telegram API
- **Winston** - логирование с ротацией файлов
- **Swagger** - API документация

**Дополнительные библиотеки:**
- `@a2seven/yoo-checkout` - интеграция с YooKassa
- `pg` - PostgreSQL клиент
- `uuid` - генерация уникальных ID
- `dotenv` - управление переменными окружения

### Frontend

**Основные технологии:**
- **React 18** - UI библиотека
- **React Router DOM** - маршрутизация
- **Zustand** - управление состоянием (stores)
- **Telegram Web App SDK** - интеграция с Telegram Mini App API

**Особенности:**
- SPA (Single Page Application)
- Client-side routing
- Локальное хранение состояния через Zustand persist
- Адаптивный дизайн под Telegram UI

## Функциональность

### 1. Telegram Bot

**Компонент:** `src/telegram/Bot.js`

**Функции:**
- Обработка команд `/start`, `/help`
- Регистрация пользователей в реферальной системе
- Обработка реферальных ссылок (`/start ref_<userId>`)
- Отправка уведомлений через Telegram Bot API
- Обработка сообщений и callback queries

**События:**
- `referral.registered` - новый реферал зарегистрирован
- Эмитится через EventBus для системы уведомлений

### 2. Реферальная система

**Компоненты:**
- `src/referral/ReferralStorage.js` - хранилище данных
- `src/http/ReferralApi.js` - REST API endpoints

**Функциональность:**
- Регистрация пользователей с привязкой к рефереру
- Двухуровневая система начислений:
  - **Уровень 1:** 30% от покупки реферала
  - **Уровень 2:** 10% от покупки реферала второго уровня
- Статистика по рефералам и заработкам
- API для получения статистики пользователя

**База данных:**
- Таблица `users`:
  - `id` (VARCHAR) - Telegram user ID
  - `username` (VARCHAR)
  - `referrer_id` (VARCHAR) - ID реферера
  - `earnings_level1` (DECIMAL) - заработок с 1 уровня
  - `earnings_level2` (DECIMAL) - заработок со 2 уровня
  - `joined_at` (TIMESTAMP)

**События:**
- `referral.registered` - при регистрации нового реферала
- `referral.purchase` - при покупке реферала
- `referral.income_credited` - при начислении дохода

### 3. Система уведомлений

**Компоненты:**
- `src/notification/NotificationService.js` - бизнес-логика
- `src/notification/NotificationWorker.js` - воркер для обработки очереди
- `src/notification/NotificationStorage.js` - хранилище в БД
- `src/notification/NotificationRateLimiter.js` - rate limiting
- `src/notification/NotificationTemplates.js` - шаблоны сообщений
- `src/http/NotificationApi.js` - REST API

**Архитектура:**
1. **Event-Driven:** Слушает события через EventBus
2. **Queue-Based:** Использует BullMQ для асинхронной обработки
3. **Rate Limited:** Многоуровневое ограничение скорости отправки
4. **Persistent:** Все уведомления сохраняются в PostgreSQL

**Типы уведомлений:**
- `purchase` - подтверждение покупки (приоритет 1)
- `referral_registered` - новый реферал (приоритет 10)
- `referral_purchase` - покупка реферала (приоритет 5)
- `income_credited` - начисление дохода (приоритет 1)

**Rate Limiting:**
- **Глобальный лимитер:** 20 сообщений/секунду (запас от лимита Telegram 30/сек)
- **Пользовательский лимитер:** 15 уведомлений/минуту на пользователя
- **Concurrency:** Максимум 3 одновременных отправки

**База данных:**
- Таблица `notifications` - история уведомлений
- Таблица `notification_preferences` - настройки пользователей
- Расширение таблицы `users` полями для отслеживания блокировок бота

**Особенности:**
- Автоматическое определение блокировок бота пользователем
- Retry механизм с экспоненциальной задержкой
- Очистка неактивных rate limiters для предотвращения утечек памяти
- Graceful degradation при недоступности Redis

### 4. Платежная система

**Компоненты:**
- `src/payment/YooKassa.js` - интеграция с YooKassa
- `src/http/Api.js` - endpoints для платежей

**Функциональность:**
- Создание платежей через YooKassa
- Webhook для обработки событий платежей
- Обработка событий:
  - `payment.succeeded` - успешная оплата
  - `payment.waiting_for_capture` - ожидание подтверждения
  - `payment.canceled` - отмена платежа
  - `refund.succeeded` - возврат средств

**События:**
- `payment.succeeded` - эмитится при успешной оплате, триггерит уведомления и реферальную систему

### 5. Магазин товаров

**Компоненты:**
- `src/shop/Products.js` - каталог товаров
- `src/http/Api.js` - API endpoints
- Frontend: `src/screens/shop/ShopScreen.jsx`

**Функциональность:**
- Каталог товаров (в памяти, можно расширить до БД)
- API для получения списка и деталей товара
- Интеграция с платежной системой для покупки

**Текущая реализация:**
- Товары хранятся в объекте `PRODUCTS` (in-memory)
- При масштабировании необходимо перенести в БД

### 6. Frontend (React)

**Структура:**
- **Screens:** Главный экран, магазин, настройки уведомлений
- **Components:** UI компоненты в стиле Telegram
- **Stores:** Zustand stores для состояния
- **Hooks:** Кастомные хуки (useTelegram, useApiRequest)
- **Utils:** API клиент, обработка ошибок

**Основные экраны:**
- `/` - главный экран
- `/shop` - магазин товаров
- `/notifications` - настройки уведомлений
- `/server` - тестовый экран для отправки сообщений

**State Management:**
- `userStore` - данные пользователя, авторизация
- `productsStore` - каталог товаров с кэшированием
- `referralStore` - реферальная статистика
- `notificationStore` - настройки уведомлений

## Узлы и компоненты

### Event Bus

**Расположение:** `src/app/Application.js`

**Назначение:**
- Централизованная система событий для межмодульной коммуникации
- Позволяет слабо связанным модулям обмениваться событиями
- Используется для триггеров уведомлений

**События:**
- `payment.succeeded` - успешная оплата
- `referral.registered` - регистрация реферала
- `referral.purchase` - покупка реферала
- `referral.income_credited` - начисление дохода

**Преимущества:**
- Декoupling модулей
- Легкое добавление новых подписчиков
- Асинхронная обработка событий

### Rate Limiter

**Расположение:** `src/notification/NotificationRateLimiter.js`

**Назначение:**
- Предотвращение превышения лимитов Telegram Bot API
- Защита от спама пользователям
- Управление нагрузкой на систему

**Механизм:**
- **Bottleneck** библиотека для rate limiting
- Двухуровневая система: глобальный + пользовательский лимитер
- Автоматическая очистка неактивных лимитеров

**Параметры:**
- Глобальный: 20 req/sec, maxConcurrent: 3
- Пользовательский: 15 req/min, maxConcurrent: 1
- Максимум 500 активных пользовательских лимитеров

### Notification Worker

**Расположение:** `src/notification/NotificationWorker.js`

**Назначение:**
- Обработка задач из очереди BullMQ
- Отправка уведомлений через Telegram Bot API
- Обработка ошибок и retry логика

**Особенности:**
- Concurrency: 3 одновременных задачи
- Автоматический retry при ошибках
- Обработка специфичных ошибок Telegram API (403, 400, 429)
- Отслеживание блокировок бота

### Logger

**Расположение:** `src/utils/logger.js`

**Назначение:**
- Централизованное логирование
- Ротация логов по дням
- Разделение уровней логирования

**Особенности:**
- Winston с daily rotate file
- Хранение логов 7-14 дней
- Раздельные файлы для errors и combined logs
- Production режим: только errors в console

## Тонкие места и ограничения

### 1. Масштабирование базы данных

**Проблема:**
- Реферальная система использует простые SQL запросы без оптимизации
- При большом количестве пользователей запросы статистики могут быть медленными
- Нет индексов на часто используемые поля (кроме `referrer_id`)

**Рекомендации:**
- Добавить индексы на `users.joined_at`, `users.earnings_level1`, `users.earnings_level2`
- Рассмотреть денормализацию для быстрого доступа к статистике
- Использовать материализованные представления для агрегированной статистики
- Добавить кэширование часто запрашиваемых данных (Redis)

### 2. Хранение товаров

**Проблема:**
- Товары хранятся в памяти (in-memory object)
- Нет возможности динамически добавлять/изменять товары
- Нет истории покупок, инвентаря, управления складом

**Рекомендации:**
- Перенести товары в PostgreSQL таблицу
- Добавить CRUD API для управления товарами
- Реализовать систему инвентаря для физических товаров
- Добавить категории, фильтры, поиск

### 3. Rate Limiter Memory Leaks

**Проблема:**
- User limiters создаются для каждого пользователя и хранятся в Map
- При большом количестве пользователей может быть утечка памяти
- Cleanup интервал 30 минут может быть недостаточным

**Текущее решение:**
- Автоматическая очистка неактивных лимитеров каждые 30 минут
- Максимум 500 активных лимитеров
- Очистка при graceful shutdown

**Рекомендации:**
- Рассмотреть использование Redis для хранения состояния лимитеров
- Уменьшить интервал cleanup до 10-15 минут
- Добавить мониторинг размера Map с лимитерами

### 4. Notification System Dependencies

**Проблема:**
- Система уведомлений критически зависит от Redis
- При недоступности Redis система деградирует, но не падает
- Нет механизма восстановления после сбоя Redis

**Текущее решение:**
- Graceful degradation: система продолжает работать без уведомлений
- Retry стратегия для подключения к Redis
- Логирование ошибок подключения

**Рекомендации:**
- Добавить fallback механизм (например, отправка через прямые вызовы API)
- Реализовать health checks для Redis
- Добавить алерты при недоступности Redis
- Рассмотреть использование PostgreSQL для очереди как fallback

### 5. Монолитная архитектура

**Проблема:**
- Все сервисы в одном процессе
- Невозможно масштабировать отдельные компоненты независимо
- Единая точка отказа

**Рекомендации:**
- Рассмотреть микросервисную архитектуру:
  - Отдельный сервис для уведомлений
  - Отдельный сервис для платежей
  - Отдельный сервис для реферальной системы
- Использовать message queue (RabbitMQ, Kafka) для межсервисной коммуникации
- Добавить API Gateway для маршрутизации запросов

### 6. Отсутствие транзакций

**Проблема:**
- При обработке продажи и начислении реферальных бонусов нет транзакций
- Возможна потеря данных при сбое между операциями
- Нет механизма отката при ошибках

**Рекомендации:**
- Обернуть `processSale` в транзакцию PostgreSQL
- Добавить idempotency keys для платежей
- Реализовать saga pattern для распределенных транзакций

### 7. Frontend State Management

**Проблема:**
- Zustand stores не синхронизируются между вкладками
- Нет механизма синхронизации с сервером
- Кэш товаров может устаревать

**Рекомендации:**
- Добавить механизм синхронизации состояния с сервером
- Реализовать optimistic updates
- Добавить WebSocket для real-time обновлений
- Использовать React Query для управления серверным состоянием

### 8. Безопасность

**Проблемы:**
- Нет валидации входных данных на некоторых endpoints
- Нет rate limiting для API endpoints
- Нет аутентификации для административных endpoints
- Webhook от YooKassa не проверяется на подлинность

**Рекомендации:**
- Добавить валидацию через Joi или Zod
- Реализовать rate limiting для API (express-rate-limit)
- Добавить JWT токены для административных endpoints
- Проверять подпись webhook от YooKassa
- Добавить CORS политики
- Использовать helmet.js для безопасности заголовков

### 9. Мониторинг и Observability

**Проблемы:**
- Нет метрик производительности
- Нет трейсинга запросов
- Логи не структурированы для анализа
- Нет алертов при ошибках

**Рекомендации:**
- Интегрировать Prometheus для метрик
- Добавить OpenTelemetry для трейсинга
- Структурировать логи в JSON формате
- Настроить алерты (PagerDuty, Opsgenie)
- Добавить health check endpoints
- Использовать APM инструменты (New Relic, Datadog)

### 10. Тестирование

**Проблемы:**
- Минимальное покрытие тестами
- Нет интеграционных тестов
- Нет E2E тестов

**Рекомендации:**
- Увеличить покрытие unit тестами до 80%+
- Добавить интеграционные тесты для API
- Реализовать E2E тесты для критических сценариев
- Добавить тесты производительности (load testing)
- Настроить CI/CD с автоматическим запуском тестов

## Рекомендации по масштабированию

### Горизонтальное масштабирование

1. **Load Balancer:** Добавить nginx или cloud load balancer перед несколькими инстансами backend
2. **Stateless Backend:** Убедиться, что backend не хранит состояние (использовать Redis для сессий)
3. **Database Replication:** Настроить read replicas для PostgreSQL
4. **Redis Cluster:** Использовать Redis Cluster для распределенного кэширования

### Вертикальное масштабирование

1. **Connection Pooling:** Оптимизировать размер пула соединений PostgreSQL
2. **Worker Scaling:** Увеличить concurrency в NotificationWorker при необходимости
3. **Rate Limiter Tuning:** Настроить параметры rate limiter под нагрузку

### Оптимизация производительности

1. **Database Indexing:** Добавить индексы на часто запрашиваемые поля
2. **Query Optimization:** Оптимизировать медленные SQL запросы
3. **Caching Strategy:** Кэшировать часто запрашиваемые данные (Redis)
4. **CDN:** Использовать CDN для статических файлов frontend

## Заключение

Проект представляет собой функциональное Telegram Mini App с реферальной системой, платежами и уведомлениями. Архитектура позволяет быстро развивать функциональность, но требует оптимизации для масштабирования на большое количество пользователей. Основные направления для улучшения: база данных, мониторинг, безопасность и тестирование.



